using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

using GenHTTP.Abstraction.Elements;

namespace GenHTTP.Abstraction.Compiling
{

    /// <summary>
    /// The DocumentCompiler allows you to compile documents to greatly improve the performance
    /// of site delivery.
    /// </summary>
    public class DocumentCompiler
    {
        private Document _Document;
        private Exception _Error;

        #region Constructors

        /// <summary>
        /// Create a new compiler instance.
        /// </summary>
        /// <param name="document">The document to compile</param>
        public DocumentCompiler(Document document)
        {
            if (document == null) throw new ArgumentNullException();
            _Document = document;
        }

        #endregion

        #region get-/setters

        /// <summary>
        /// The error which occured during compilation.
        /// </summary>
        public Exception Error
        {
            get { return _Error; }
        }

        #endregion

        #region Compilation

        /// <summary>
        /// Compile the given document.
        /// </summary>
        /// <param name="file">The file to compile to</param>
        /// <param name="usedNamespace">The namespace to use</param>
        /// <param name="documentName">The name of the document</param>
        /// <returns>true, if the operation succeeded</returns>
        public bool Compile(string file, string usedNamespace, string documentName)
        {
            if (_Document == null) throw new ArgumentNullException("You need to set the document before you can compile any");
            if (file == null || file.Length == 0) throw new ArgumentException("You need to specify a file to write to", "file");
            if (usedNamespace == null || usedNamespace.Length == 0) throw new ArgumentException("You need to specify the namespace to use", "usedNamespace");
            if (documentName == null || documentName.Length == 0) throw new ArgumentException("You need to specify the name of the document", "documentName");
            try
            {
                // reset errors and open stream for writing
                _Error = null;
                StreamWriter w = new StreamWriter(file, false, _Document.Encoding.Encoding);
                try
                {
                    // write header of the file
                    w.WriteLine("/*");
                    w.WriteLine("");
                    w.WriteLine("  Template " + documentName);
                    w.WriteLine("");
                    w.WriteLine("  Generated by the GenHTTP document compiler v0.01");
                    w.WriteLine("");
                    w.WriteLine("*/");
                    w.WriteLine("using System;");
                    w.WriteLine("using System.Text;");
                    w.WriteLine("using System.Collections.Generic;");
                    w.WriteLine("");
                    w.WriteLine("using GenHTTP.Abstraction;");
                    w.WriteLine("using GenHTTP.Abstraction.Compiling;");
                    w.WriteLine("");
                    w.WriteLine("namespace " + usedNamespace + " {");
                    w.WriteLine("");
                    // structures to store data
                    List<string> staticContent = new List<string>();
                    List<string[]> placeholders = new List<string[]>();
                    // analyze document
                    string toParse = _Document.SerializeToString();
                    Regex re = new Regex(Regex.Escape("%GENHTTP PLACEHOLDER TYPE: ") + "([^ ]+)" + Regex.Escape(" NAME: ") + "([^%]+)" + Regex.Escape("%"));
                    // retrieve first match
                    Match match = re.Match(toParse);
                    while (match.Success)
                    {
                        // add the text before this match (which is static)
                        staticContent.Add(toParse.Substring(0, match.Index));
                        // add the placeholder
                        placeholders.Add(new string[] { match.Groups[1].Value, match.Groups[2].Value });
                        // shorten the remaining text
                        toParse = toParse.Substring(match.Index + match.Length);
                        // get next match
                        match = re.Match(toParse);
                    }
                    // add the remaining text without matches
                    if (toParse.Length > 0) staticContent.Add(toParse);
                    // write base class
                    w.WriteLine("  internal class " + documentName + "Base : ITemplateBase {");
                    // define attributes and initialize them
                    w.WriteLine("    private long _ContentLength;");
                    w.WriteLine("    private Encoding _Encoding;");
                    w.WriteLine("    private List<byte[]> _Parts;");
                    w.WriteLine("    private DocumentType _Type = DocumentType." + _Document.Type.ToString() + ";");
                    w.WriteLine("");
                    w.WriteLine("    public " + documentName + "Base() {");
                    w.WriteLine("      _Encoding = Encoding.GetEncoding(\"" + _Document.Encoding.Name + "\");");
                    w.WriteLine("      _Parts = new List<byte[]>(" + staticContent.Count + ");");
                    foreach (string part in staticContent)
                    {
                        w.WriteLine("      _Parts.Add(_Encoding.GetBytes(\"" + part.Replace("\"", "\\\"").Replace("\r\n", "\\r\\n") + "\"));");
                    }
                    w.WriteLine("      _ContentLength = " + staticContent.Sum((string s) => s.Length) + ";");
                    w.WriteLine("    }");
                    // write get-/setters
                    w.WriteLine("");
                    w.WriteLine("    public Encoding Encoding {");
                    w.WriteLine("      get { return _Encoding; }");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    w.WriteLine("    public byte[] this[int nr] {");
                    w.WriteLine("      get { return _Parts[nr]; }");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    w.WriteLine("    public long ContentLength {");
                    w.WriteLine("      get { return _ContentLength; }");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    w.WriteLine("    public DocumentType Type {");
                    w.WriteLine("      get { return _Type; }");
                    w.WriteLine("    }");
                    w.WriteLine();
                    w.WriteLine("  }");
                    w.WriteLine("");
                    w.WriteLine("  internal class " + documentName + " : ITemplate {");
                    w.WriteLine("    private ITemplateBase _Base;");
                    w.WriteLine("    private List<byte[]> _Content;");
                    // write placeholders
                    foreach (string[] placeholder in placeholders.Distinct())
                    {
                        w.WriteLine("    private " + placeholder[0] + " _" + placeholder[1] + ";");
                    }
                    w.WriteLine("");
                    w.WriteLine("    public " + documentName + "(ITemplateBase baseClass) {");
                    w.WriteLine("      _Content = new List<byte[]>(" + placeholders.Count + ");");
                    w.WriteLine("      _Base = baseClass;");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    w.WriteLine("    public ITemplateBase Base {");
                    w.WriteLine("      get { return _Base; }");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    // write get-/setters for every placeholder
                    foreach (string[] placeholder in placeholders.Distinct())
                    {
                        w.WriteLine("    public " + placeholder[0] + " " + placeholder[1] + " {");
                        w.WriteLine("      get { return _" + placeholder[1] + "; }");
                        w.WriteLine("      set { _" + placeholder[1] + " = value; }");
                        w.WriteLine("    }");
                        w.WriteLine("");
                    }
                    // write serialization
                    w.WriteLine("    public byte[] ToByteArray() {");
                    foreach (string[] placeholder in placeholders)
                    {
                        Type type = Type.GetType(placeholder[0]);
                        if (type.IsSubclassOf(typeof(Element)))
                        {
                            w.WriteLine("      _Content.Add(_Base.Encoding.GetBytes(_" + placeholder[1] + ".Serialize(_Base.Type)));");
                        }
                        else if (type == typeof(string))
                        {
                            w.WriteLine("      _Content.Add(_Base.Encoding.GetBytes(_" + placeholder[1] + "));");
                        }
                        else if (type == typeof(SnippetContainer))
                        {
                            w.WriteLine("      _Content.Add(" + placeholder[1] + ".ToByteArray());");
                        }
                        else
                        {
                            w.WriteLine("      _Content.Add(_Base.Encoding.GetBytes(_" + placeholder[1] + ".ToString()));");
                        }
                    }
                    // calculate content length
                    w.Write("      long contentLength = " + staticContent.Sum((string s) => s.Length));
                    int i = 0;
                    foreach (string[] placeholder in placeholders)
                    {
                        w.Write(" + _Content[" + i++ + "].Length");
                    }
                    w.WriteLine(";");
                    w.WriteLine("      byte[] ret = new byte[contentLength];");
                    w.WriteLine("      int nextPos = 0;");
                    i = 0;
                    // serialization main part
                    foreach (string[] placeholder in placeholders)
                    {
                        w.WriteLine("      // " + placeholder[1]);
                        w.WriteLine("      System.Buffer.BlockCopy(_Base[" + i + "], 0, ret, nextPos, " + staticContent[i].Length + ");");
                        w.WriteLine("      nextPos += _Base[" + i + "].Length;");
                        w.WriteLine("      System.Buffer.BlockCopy(_Content[" + i + "], 0, ret, nextPos, _Content[" + i + "].Length);");
                        w.WriteLine("      nextPos += _Content[" + i + "].Length;");
                        i++;
                    }
                    w.WriteLine("      System.Buffer.BlockCopy(_Base[" + i + "], 0, ret, nextPos, _Base[" + i + "].Length);");
                    w.WriteLine("      return ret;");
                    w.WriteLine("    }");
                    w.WriteLine("");
                    w.WriteLine("  }");
                    // write footer of the file
                    w.WriteLine("");
                    w.WriteLine("}");
                    w.WriteLine("");
                }
                catch (Exception e)
                {
                    // a error occured .. save it
                    _Error = e;
                }
                // close file
                w.Close();
            }
            catch (Exception ex)
            {
                // failed to open the file
                throw new IOException("Failed to write to the given file.", ex);
            }
            // was there any error?
            return _Error == null;
        }

        #endregion

    }

}
